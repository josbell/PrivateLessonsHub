const Nightmare = require('nightmare')

exports.options = {}
exports.config = {
	useragent: 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36',
	challenges: [
		{
			type: 'email',
			value: 12
		},
		{
			type: 'phoneNumber',
			value: 13
		},
		{
			type: 'secret_answer',
			input: 'answer',
			value: 15
		}
	]
}

exports.getCode = function (url, params, timeout) {
	"use strict"

	const nightmare = new Nightmare(exports.options)
	const newPassword = null
	const challenges = exports.config.challenges.slice()

	return new Promise((resolve, reject) => {
		nightmare
			.viewport(800, 1600)
			.useragent(exports.config.useragent)
			.use(start)

		// Set up the timeout
		let promiseTimeout;
		if (timeout !== undefined)
			promiseTimeout = setTimeout(() => {
				nightmare.end(_ => { })
				reject('Promise timed out after ' + timeout + ' ms')
			}, timeout)

		function start(nightmare) {
			nightmare
				.goto(url)
				.then(gotoResult => {
					debug('Status Code:', gotoResult.code)
					if (gotoResult.code == 200) {
						nightmare
							.use(login)
							.use(challenge)
					} else {
						nightmare.end(_ => { })
						clearTimeout(promiseTimeout)
						reject('Client ID Wrong')
					}
				}).catch(error => {
					clearTimeout(promiseTimeout)
					reject(error)
				})
		}

		function login(nightmare) {
			nightmare
				.wait('input[type=email]')
				.insert('input[type=email]', params.email)
				.click('#next')
				.wait(1000)
				.wait('input[type=password]')
				.insert('input[type=password]', params.password)
				.click('#signIn')
				.wait(2000)
		}

		function submit(nightmare) {
			debug('submitting approve access')
			nightmare
				.wait('#submit_approve_access')
				.wait(1500)
				.click('#submit_approve_access')
				.wait(1500)
				.evaluate(() => document.querySelector('#code').value)
				.end()
				.then(result => {
					clearTimeout(promiseTimeout)
					resolve({
						code: result,
						password: newPassword
					})
				})
		}

		function challenge(nightmare) {
			if (params.challenge) {
				nightmare.use(checkBlock)
			} else {
				nightmare.use(submit)
			}
		}

		function checkBlock(nightmare) {
			debug('check if the account has been blocked')
			nightmare.wait(1000)
				.exists('#idvreenable')
				.then(exists => {
					if (exists) {
						return nightmare.end().then(() => {
							clearTimeout(promiseTimeout)
							reject('This account has been blocked')
						})
					} else {
						nightmare.use(selectChallenge)
					}
				})
		}

		function selectChallenge(nightmare) {
			debug('checking challenge exists')
			nightmare
				.wait(2000)
				.exists('#challengePickerList')
				.then(exists => {
					if (exists) {
						debug('select challenge')

						function __selectChallenge() {
							debug('existing challenges', challenges)
							if (challenges.length == 0) {
								return nightmare.end().then(() => {
									clearTimeout(promiseTimeout)
									reject('No more chanllenge type')
								})
							}
							const challenge = challenges.shift()
							debug('using chanllenge', challenge)
							if (params.challenge[challenge.type] !== undefined) {
								debug('Trying to use', challenge.type)

								const query = `input[name="challengeType"][type="hidden"][value="${challenge.value}"]`
								console.log(query)
								nightmare.exists(query)
									.then(exists => {
										if (exists) {
											debug('Using challenge type', challenge.type)
											nightmare.evaluate(query => {
												console.log('Trying to click button', query)
												const el = document.querySelector(query).parentElement.querySelector('button')
												const event = document.createEvent('MouseEvent')
												event.initEvent('click', true, false);
												el.dispatchEvent(event)
												return el ? true : false
											}, query).run((error, exists) => {
												if (error) {
													return nightmare.end().then(() => {
														clearTimeout(promiseTimeout)
														reject(error)
													})
												}
												if (!exists) {
													debug(challenge.type, 'not exists in form. Trying use different.')
													__selectChallenge()
												} else {
													nightmare.use(startChallenge)
												}
											})
										} else {
											debug(challenge.type, 'not exists in selection. Trying use different.')
											__selectChallenge()
										}
									})
							} else {
								debug(challenge.type, 'not configured. Trying use different.')
								__selectChallenge()
							}
						}
						__selectChallenge()
					} else {
						nightmare.use(startChallenge)
					}
				})
		}

		function startChallenge(nightmare) {
			debug('waiting for challenge type')
			nightmare
				.wait(2000)
				.exists('#challenge')
				.then(exists => {
					if (exists) {
						nightmare
							.wait(1000)

						const challenges = exports.config.challenges.slice()
						function __startChallenge() {
							if (challenges.length == 0) {
								return nightmare.end().then(() => {
									clearTimeout(promiseTimeout)
									reject('Chanllenge type not exists.')
								})
							}
							const challenge = challenges.shift()
							const query = `input[name=${challenge.input || challenge.type}]`
							console.log(query)
							nightmare.exists(query)
								.then(exists => {
									if (exists) {
										debug('recovery by', challenge.type)
										nightmare
											.insert(query, params.challenge[challenge.type])
											.wait(1000)
											.click('input[type=submit]')
											.use(checkChallenge)
									} else {
										__startChallenge()
									}
								})
						}
						__startChallenge()
					} else {
						nightmare.use(submit)
					}
				})
		}

		function checkChallenge(nightmare) {
			debug('checking recovery inputs')
			nightmare
				.wait(2000)
				.exists('#error')
				.then(exists => {
					if (exists) {
						debug('recovery inputs error')
						nightmare
							.evaluate(() => document.querySelector('#error').innerHTML)
							.run((error, html) => {
								if (error) {
									return nightmare.end().then(() => {
										clearTimeout(promiseTimeout)
										reject('No more chanllenge type')
									})
								}
								debug(html)
								debug('Trying to use different challenge type')
								nightmare
									.click('#skipChallenge')
									.use(selectChallenge)
							})
					} else {
						nightmare.use(challengeResetPassword)
					}
				})
		}

		function challengeResetPassword(nightmare) {
			debug('doing challenge reset password')

			nightmare
				.wait(2000)
				.exists('#ConfirmPassword')
				.then(exists => {
					if (exists) {
						debug('reseting password')
						nightmare
							.insert('#ConfirmPassword', params.challenge.password)
							.wait(500)
							.insert('#Password', params.challenge.password)
							.wait(500)
							.click('input[type=submit]')
							.wait(1000)

						newPassword = params.challenge.password
					} else {
						debug('skip reset password')
					}

					nightmare.use(submit)
				})
		}
	})

	function debug() {
		if (params.debug)
			console.log.apply(console, arguments)
	}

}